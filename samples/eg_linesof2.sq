
#_(def struct
  (make-macro-fn
    .param-syms [:form]
    .code
    (quote
      (make-struct
        .members))))

;; intrinsics:
;; macros: [fn struct let do set if cast foreign-proc]
;; functions: [foreign-library + - *]

#_(def Counted-Array
  (struct
    (count int)
    (data rawptr)))

; (def Any
;   (struct
;     (type Type-Info)
;     (data rawptr)))




(def Foreign-Lib
  (struct
    (path String)))

(def foreign-library
  (fn [(path String)] -> (_ Foreign-Lib)
    (do
      (let lib (new Foreign-Lib))
      (set lib/path path)
      lib)))

(def Foreign-Proc-C-Type
  (enum
    [:nil :void :bool :char :short :int :long :longlong
     :float :double :pointer :aggregate]))

(def Decl-Foreign-Proc
  (struct
    (name String)
    (lib Foreign-Lib)
    (param-types (tArr Foreign-Proc-C-Type))
    #_(ret-type Foreign-Proc-C-Type)
    (ret-typeinfo *Type-Info)))

(def foreign-proc
  (fn [(params (tArr Any))
       (ret-type *Type-Info)
       (name String)
       (lib Foreign-Lib)]
    -> (_ Decl-Foreign-Proc)
    (do
      (let r (new Decl-Foreign-Proc))
      (set r/name name)
      (set r/lib lib)
      ; (set r/ret-type ret-type)

      ; (prn r)
      ; (prn ret-type)
      ; (prn r/ret-typeinfo)
      (set r/ret-typeinfo ret-type)
      
      #_(set r/param-types (make-arr Foreign-Proc-C-Type params/count))
      r)))

(def typeinfo-to-foreign-c-type
  (fn [(typeinfo Type-Info)]
    -> (_ Foreign-Proc-C-Type)
    ;; problem: C's int could be 32 or 64 bits depending
    ;; on how the library was compiled
    (case typeinfo/tag
      [:void :void]
      [:bool :bool]
      [:integer
       (do
         (let nbits typeinfo/integer/nbits)
         (case nbits
           [8 :char]
           [16 :short]
           [32 :int]
           [64 :longlong]))]
      [:float
       (do
         (let nbits typeinfo/float/nbits)
         (case nbits
           [32 :float]
           [64 :double]))]
      [:pointer :pointer])))

(def CALL_C_X86_WIN32_STD 2)

(def invoke-foreign-proc
  (fn [(fp Decl-Foreign-Proc)
       (args (tArr Any))]
    -> (_ Any)
    (do
      ; (prn fp)
      ; (prn fp/ret-typeinfo)
      (bootstrap-foreign-dyncall
        ; fp/lib/path
        "Kernel32.dll"
        fp/name
        CALL_C_X86_WIN32_STD
        args
        fp/ret-typeinfo))
    #_(do
      (let i 0)
      (let param-types fp/param-types)
      (jumps :loop
        (do
          (if (< i args/count)
            (do
              (let arg (args i))
              (let argti arg/type)
              (let pct (param-types i))
              ;; .......
              (set' i (+ 1 i))
              (goto :loop))
            0))))))




(def Kernel32 (foreign-library "Kernel32.dll"))

; (def GetLastError (foreign-proc [] u32 "GetLastError" Kernel32))
(def GetProcessHeap (foreign-proc [] rawptr "GetProcessHeap" Kernel32))
(def HeapAlloc (foreign-proc [[:heap rawptr] [:flags u32] [:nbytes uint]] rawptr "HeapAlloc" Kernel32))


;; FIXME: does not work because returns a typeinfo of
;; a different pointer to canonical s64.
;; this is because Type-Info is stored by value
;; in the foreign proc struct, so gets copied.
(def allocate
  (fn [(nbytes int)] -> (memory rawptr)
    (do
      (let HEAP_ZERO_MEMORY 8)
      (HeapAlloc (GetProcessHeap) 0 nbytes))))

(def cstring
  (fn [(s String)] -> rawptr
    (do
      (let cs (allocate (+ 1 s/count)))
      (memcopy cs s/data s/count)
      cs)))

(def Point
  (struct
    (x int)
    (y int)))

#_(def String
  (struct
    (count int)
    (data rawptr)))

(def File-Time
  (struct
    (low-date-time u32)
    (high-date-time u32)))

(def Win32-Find-Data
  (struct
    (file-attributes u32)
    (creation-time File-Time)
    (last-access-time File-Time)
    (last-write-time File-Time)
    (file-size-high u32)
    (file-size-low u32)
    (reserved0 u32)
    (reserved1 u32)
    (file-name (tArr u16 260))
    (alternate-file-name (tArr u16 14))
    (_obsolete_file-type u32)
    (_obsolete_creator-type u32)
    (_obsolete_finder-flags u16)))

(def Caller-Context
  (struct
    (thread rawptr)
    (allocator rawptr)
    (allocator-data rawptr)
    (thread-locals rawptr)))

(def root-allocator-proc
  (fn [(op int) (nbytes int) (alignment int)]
    -> (memory rawptr)
    (do
      (allocate nbytes))))


(def test
  (fn [(fp Decl-Foreign-Proc)]
    (do
      (prn fp/ret-typeinfo))))

(def test2
  (fn [(s String)]
    (do
      (prn s/data))))

(def main
  (do
    (bootstrap-register-data-invoker Decl-Foreign-Proc
      invoke-foreign-proc)
    ; (let x "hello")
    ; (prn x/data)
    ; (test2 "hello")
    #_(do
      (let r (new Decl-Foreign-Proc))
      (set r/name "hello")
      (set r/ret-typeinfo u64)
      
      (prn r/ret-typeinfo)
      (test r))
    ; #_
    (fn []
      (do
        (let dir (cstring ".\\*"))
        (let file-data (new Win32-Find-Data))
        dir))))